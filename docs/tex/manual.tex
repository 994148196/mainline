\documentclass[12pt]{article}
\usepackage{makeidx}
\usepackage{url}
%\usepackage[pdftex]{hyperref}

\newcommand{\bR}{{\bf R}}
\newcommand{\bX}{{\bf X}}
\newcommand{\bx}{{\bf x}}
\newcommand{\br}{{\bf r}}
\newcommand{\bk}{{\bf k}}
\usepackage{amsmath}
\usepackage{fullpage}
%\makeindex
\begin{document}
\begin{titlepage}
\begin{center}

\vspace{1cm}
{\Huge {\sc U s e r' s \, \, G u i d e}}

\vspace{1cm}
\hrulefill
\vspace{1cm}

{\Huge {\bf Q W A L K }}

\vspace{1cm}
\hrulefill
\vspace{1cm}
\end{center}

\end{titlepage}

\tableofcontents

\newpage

\section{Introduction}

\section{Trial functions: conversion}

\subsection{GAMESS}
Description

Basic usage: gamess2qmc -o [outputroot]  [gamess output root] \\
Additional options: \\

\begin{tabular}{lp{8cm}}
\hline
 Option & Description \\
\hline
-o [outputroot] & Use [outputroot] as the base for the QWalk run.
Gamess2qmc will then create files like outputroot.slater, etc.\\
-compare\_punch [filename]  &  Compares the orbitals in the current punch file to the one specifiedhere.  Will print what orbitals have changed/rotated, and if any cannot be mapped back between the two wave functions. \\
-virtual [number] & Include this number of virtual orbitals into the orb file.  Defaults to 3. \\
\hline
\end{tabular}

%\newpage
\subsection{Gaussian}
\subsubsection{Notes on Running Gaussian}

Options necessary: \\
\begin{tabular}{lp{8cm}}
iop(3/24=10) & Print gaussian functions \\
iop(3/18=1) & Print pseudopotentials \\
6d 10f & Use 6d and 10f functions, which is what the converter was written for (this requirement could be removed in the future, if someone has the will) \\
\end{tabular}

Useful options \\
\begin{tabular}{lp{8cm}}
pseudo=read & read in the pseudopotentials \\
gen & i.e., UHF/gen, etc. Allows you to enter the basis. \\
\end{tabular}

For example, your com file may look like \\
\begin{verbatim}
%chk=foo.chk
#P B3LYP/gen 6d 10f scf opt test iop(3/24=10) iop(3/18=1) pseudo=read
 ...
\end{verbatim}
After running g03 (g03 foo.com, for example), you must then format the
check file as \\
\begin{verbatim}
formchk foo.chk foo.fchk
\end{verbatim}
and finally you're ready to use the converter.

\subsubsection{Conversion}
Basic usage: g032qmc -log foo.log -fchk foo.fchk -out [outputoot]  \\
Additional options: \\
\begin{tabular}{lp{8cm}}
Option & Description \\
-out [comfile] & Use [outputroot] as the base for the QWalk run.
G032qmc will then create files like outputroot.slater, etc. \\
-h & print help message for more advanced usage\\
\end{tabular}

%\newpage
\subsection{Crystal}


Basic usage:  crystal2qmc -o [outputroot]  [crystal output file] \\
Additional options: \\
\begin{tabular}{lp{8cm}}
-fort10file [filename]  &  Read from the output created by the 
readcrys10.f utility and match the orbitals to the one in
the crystal output file.  These are generally more accurate than the ones
in the output file. \\
\end{tabular}



\subsubsection{Crystal98}

One needs to put the options: \\
\begin{verbatim}
COORPRT
\end{verbatim}
at the end of the geometry section, and \\
\begin{verbatim}
PRINTOUT
BASISSET
EIGENVAL
-1
EIGENVEC
-1
END
\end{verbatim}
in the third section(the one after the basis set section). 

\subsubsection{Crystal2003}

 For crystal 2003, put 
\begin{verbatim}
PRINTOUT
EIGENVAL
-1
EIGENVEC
-100
END
\end{verbatim}
in the third section as above.  To get the correct basis set, use the properties input: \\
\begin{verbatim}
BASISSET
0
END
\end{verbatim}
and cat the output into the end of the output file.  A script to do this is at the end of this section.
The -100 under EIGENVEC prints out the first 100 k-points used.  If you end up with more k-points, 
increase the absolute value of this number.  At least for 2003(and maybe 98), crystal2qmc can find all the
real k-points and prepare an input file for qwalk at non-zero k-points.  This can reduce the finite
size error in the kinetic energy significantly if you choose your k-point well(in a cubic supercell, the 
111 direction minimizes the error, for example).

To use the fort10file option with crystal98 or 2003, one must use NOSYMADA in
the last section.  This turns off a feature that boosts the speed quite a bit in certain circumstances, but
mangles the wavefunction in fort.10.  

Further considerations:\\
Finite size errors are a bit more problematic within QMC, since we do the calculation for only one
k-point, and there are finite size effects related to the electron correlation hole.  There are papers in the literature that discuss this problem extensively.
So, we have to use a supercell, at least  2x2x2.



\subsubsection{Script to run crystal2003}

Make sure to put the PRINTOUT, etc in the input file..  Also, you may need to change SCRATCH, CRYSTAL, and 
PROPERTIES to reflect the location of these files/directories on your system.
\begin{verbatim}
#!/bin/bash


SCRATCH=/state/partition1/scratch/$USER
if [ ! -e $SCRATCH ]
    then
    #first try to make the scratch directory.
    mkdir $SCRATCH
    #if it's still not there, error
    if [ ! -e $SCRATCH ]
    then echo "Scratch directory $SCRATCH doesn't exist and I couldn't make it"
    exit 1;
    fi
fi

CRYSTAL=/home/apps/crystal2003/crystal
PROPERTIES=/home/apps/crystal2003/properties
CURRDIR=`pwd`
echo $CURRDIR

inputfile=$(basename $1)
echo $inputfile
mkdir $SCRATCH/$inputfile
cp $1 $SCRATCH/$inputfile/

if [ -e fort.20 ]
    then cp fort.20 $SCRATCH/$inputfile
fi

cd $SCRATCH/$inputfile

$CRYSTAL < $inputfile > $CURRDIR/$inputfile.o
echo "BASISSET" > prop.in
echo "0" >> prop.in
echo "END" >> prop.in
echo "" >> prop.in
$PROPERTIES < prop.in >> $CURRDIR/$inputfile.o
cp fort.9 $CURRDIR/$inputfile.9
cp fort.10 $CURRDIR/$inputfile.10
rm -Rf $SCRATCH/$inputfile
\end{verbatim}

%\newpage
\subsection{Siesta}
Basic usage: siesta2qmc -o [outputroot]  [siesta output file] 

If outputroot is not given, it will default to qwalk.

Getting a good trial wave function from Siesta can be a little
tricky, so here are some techniques that have worked in the past.
These are not guaranteed to obtain the most accurate numbers possible,
so be careful!

\subsubsection{Siesta Options}

The following options are required for the converter to work:
\begin{verbatim}
%block WaveFuncKPoints
0.0 0.0 0.0
%endblock WaveFuncKPoints
LongOutput .true.
LatticeConstant 
\end{verbatim}

You need the lattice constant variable even if you're calculating
a molecule, since Siesta apparently doesn't print out the orbital
coefficients unless the lattice constant is given explicitly.  If you
are doing an actual molecule, you may want to change PERIODIC in the
QWalk .sys file to MOLECULE, which will increase the speed and accuracy.

\subsubsection{Pseudopotential}

One can use the pseudopotentials generated for QMC, although they can be
quite a pain to convert for use in Siesta, since they are usually
written in a Gaussian expansion.  Current thought is that PBE psp's are
probably your best bet.  Siesta
may have exact exchange in the future, in which case hybrid or
Hartree-Fock psueudopotentials may be better.  To be clear, the
pseudopotentials should be tested, by, for example, calculating
the binding energy of small molecules.


\subsubsection{Basis set}

You may find that you need to use a larger basis set than is typical for
Siesta.  It appears that a triple-zeta quality with polarization or better
is necessary.  If the basis set is too small, the variance of the local
energy is too large, because the basis cannot describe the one-body
part of the wave function well enough.  For molecules, you may also
need to extend the cutoff radius of the basis functions significantly to
keep the variance down and the wave function accurate.


\newpage
\subsection{Homogeneous electron gas}

\newpage
\section{Methods}
\subsection{Variational Monte Carlo sampling}
Keyword: VMC \\

Evaluates the expectation value $ <\Psi|O|\Psi>/<\Psi|\Psi>$
stochastically, where $O$ is an observable.

Required keywords: \\
\begin{tabular}{lp{12cm}}
{\bf NCONFIG} & Integer. Number of sample points to use at one time,
per processor.  This will also be the number that is put into the 
configuration files if STORECONFIG is set.\\
{\bf NSTEP} & Integer.  Number of average points to take in a block \\

{\bf NBLOCK} & Integer.  Number of blocks to take \\

{\bf TIMESTEP} & Float.  A measure of how large each Metropolis move
should be.  Adjust such that the acceptance ratio is somewhat greater than
0.5 \\
\end{tabular}


Other options \\
\begin{tabular}{lp{12cm}}
{\bf NDECORR} &   Integer.
       Number of Metropolis steps to take before evaluating the energy.
           Since VMC steps don't require an energy evaluation, this serves
           to decorrelate the averaging points before doing an expensive
           evaluation of the energy(mostly pseudopotentials). Defaults to 2.\\
{\bf STORECONFIG} & String.  Write the configurations to 
this file every block.  In parallel, each processor will write its configurations to this file with \_n appended, where n is the processor number. \\
{\bf READCONFIG } & String.  Read from a configuration file
previously written by STORECONFIG.  If there are more or less configurations 
than NCONFIG, new configurations will be generated or old ones left out to
make the number exactly NCONFIG. \\
{\bf GUIDETYPE} &  String.
     Possible options: SUMSQUARES($ \Psi_T^2 = \Psi_1^2+\Psi_2^2 $), 
      SUM($ (\Psi_1 + \Psi_2)^2 $), FIRST($ \Psi_T = \Psi_1 $). Specify
the importance-sampling function. This will importance-sample only
with respect to wave functions defined in the TRIALFUNC section.  Ones
defined in AUX\_WF/AUX\_SYS will not be used, since they are auxillary, not
guiding functions. Defaults to SUMSQUARES.\\
\end{tabular}

%\newpage
\subsection{Wave function optimization: conjugate gradients}
Keyword: OPTIMIZE \\


The approach here is to use a fixed set of configurations and 
a conjugate gradient routine to minimize some quantity such as 
variance or mean absolute deviation.  This method is quite fast, 
but is not very effective at minimizing total energy or nodal 
structure.  The method keyword is OPTIMIZE.

Required keywords: \\
\begin{tabular}{lp{12cm}}
{\bf NCONFIG} &  Integer. Number of configurations per processor. \\
{\bf READCONFIG} & String. Where to read the configurations from. This 
should come from a previous VMC run.\\
\end{tabular}

Other options: \\
\begin{tabular}{lp{12cm}}
{\bf MINFUNCTION} & String.  Options are: 
\begin{itemize}
\item VARIANCE (default) : $ \sum{(E_l - E_{ref})^2} $
\item  ABSOLUTE : $ \sum{ | E_l - E_{ref} | } $
\item  LORENTZ : $ \sum{ log(1+(E_l-E_{ref})^2/2) } $
\item ENERGY : $ \frac{1}{N} \sum { E_l }  $
\item MIXED : $ mixing \frac{1}{N} \sum { E_l } + (1-mixing) \sum{(E_l - E_{ref})^2}  $
\end{itemize}
For an energy minimization, it's advisable to also use USE\_WEIGHTS. \\
{\bf USE\_WEIGHTS} & Flag. Turn on correlated sampling reweighting.  Otherwise all sums are done without weights.\\
{\bf MIXING} & Float.  If MINFUNCTION=MIXING, what proportion of energy to put in the optimization.  Defaults to 0.95, 95\% energy optimization.\\
{\bf ITERATIONS} &  Integer.  Maximum number of optimization iterations.  Defaults to 30. \\
{\bf EREF} & Float.  Guess at the optimized total energy.  If not set, it will be guessed from the initial walkers.  For large systems, sometimes this may need to be set by hand.\\
{\bf WFOUTPUT} & String.  Where to put the optimized wave function.  Defaults to runid.wfout.\\
\end{tabular}

%\newpage
\subsection{Wave function optimization: Newton's method}
Keyword: OPTIMIZE2 \\

Uses Levenberg-Marquardt algorithm to minimize wavefunction's
energy/variance or mixture of both. It uses self-adjustable 
damping parameter which is added to the diagonal of corresponding hessian.
Consequently a Newton step is performed to get new parameters.    
(See C. J. Umrigar and C. Filippi.  Phys. Rev. Lett. 94, 150201 (2005) )
The keyword is OPTIMIZE2.

Except for some experimental features, it takes the same options as OPTIMIZE 
above.  This optimize method also only supports VARIANCE, ENERGY, and 
MIXED optimizations, since the primary use is for energy optimization.

%\newpage
\subsection{Diffusion Monte Carlo}
Keyword: DMC \\

The purpose of diffusion Monte Carlo is to go beyond a variational 
\emph{ansatz}.  The major approximation is the fixed-node one.  
The energies obtained here are generally the lowest 
available upper bounds to the exact ground state energy, at least for 
large systems.  

In this implementation of DMC, we use something similar to the Umrigar
Nightingale, Runge paper, with some modifications.  Electrons are moved 
one-by-one, and there is an effective timestep for the branching part of 
the green's function.  We use a branching algorithm 
that ensures a constant number of walkers, which improves the 
parallel efficiency--it is easy to scale up to thousands of processors
with 99\% efficiency.

Required keywords: \\
\begin{tabular}{lp{12cm}}
{\bf NCONFIG} &  Integer. The desired number of walkers
per node.  This should match the VMC number used to generate the walkers. \\
{\bf NSTEP} & Integer.   Number of average points to take in a block.
 Should be such that NSTEP*TIMESTEP is approximately 1. \\
{\bf NBLOCK} & Integer.  Number of blocks to take\\
{\bf TIMESTEP} & Float.  A measure of how large each move 
should be.  Adjust such that the acceptance ratio is about .99. Acceptance ratio
is just a general guide, however, and it's useful to do several time steps, extrapolating
to zero, if you need highly accurate results.\\
{\bf  READCONFIG } & String.  Read from a configuration file
previously written by STORECONFIG.  If there are more  configurations 
than NCONFIG, DMC will read NCONFIG.  This should either be from a VMC 
run or a previous DMC run. \\
\end{tabular}

Other options: \\
\begin{tabular}{lp{12cm}}
{\bf STORECONFIG} & String.   Write the configurations and DMC 
weights to this file every block.  In parallel, each processor will write its configurations to this file with \_n appended, where n is the processor number. \\
{\bf TMOVES} & Flag. Use Michele Casula's T-moves, which
  makes DMC rigorously variational when there are non-local pseudopotentials
  at the cost of increasing the timestep error slightly.  Defaults to off \\
\end{tabular}

More advanced options that change internal parameters in the DMC calculation.  These
can generally be left as they are without affecting the accuracy of the calculation, 
so don't change these unless you know what you're doing.\\
\begin{tabular}{lp{10cm}}
{\bf LOW\_IO} & Flag. Try to limit the amount of I/O, which
is useful when the run is faster than the I/O, or in the case of writing to
flaky NFS servers.  Currently it just turns off writing 
configurations and one-body densities in intermediate blocks, only writing at the end of the run.\\
{\bf FEEDBACK } & Float.  The strength of the population control.  Set it to
 roughly 1/n, where n is the number of steps that it should take to return the 
average weight of the walkers to one. \\
{\bf FEEDBACK\_INTERVAL} & Integer.  Number of steps to wait before doing 
population control.  This can affect efficiency because of the way that QWalk 
handles more than one walker per node.  If this is too small, then the calculation 
will run slighly slower, and if it is too large, the fluctuations in 
weights tend to increase.  The default is 5, which works in most instances.\\
{\bf BRANCH\_START\_CUTOFF} & Float.  When a walker's energy is very low, we slow down the accumulation 
          of weights, eventually cutting it off.  The cutoff starts at 
          BRANCH\_START\_CUTOFF*sigma, where sigma is the standard deviation
          of the local energy.  When doing highly accurate calculations, it's 
          sometimes the case that eref appears to be biased.  One can increase
          this value, which should alleviate the problem.  The default is 10. \\
\end{tabular}

%\newpage

\subsection{Reptation Monte Carlo}
Keyword: REPTATION \\

This is an implementation of the Reptation Monte Carlo method(PRL 82, 4745 (1999)).  There are quite a few modifications to the algorithm as presented in the above paper. 
 Some are outlined in a paper by Pierleoni and Ceperley that's floating around on the net, most importantly the bounce algorithm.  RMC is conceptually similar to DMC, in t
hat we sample the distribution $\Psi_T e^{-H\tau} \Psi_T $, with the projection operator interpreted as a random walk.  At each end of the walk, we have sampled $\Psi_T \Phi_0$, the mixed distribution.  In the center, we have $\Phi_0^2$, since on either side there are projection operators.  DMC only moves forward, so the center 
distribution is unavailable, except by forward walking, which simulates the effect of projection operators.  In RMC, the random variable is the path, which, for finite len
gth, can be a probability density.  Therefore, there's no branching and no population control bias.  


The biases (and speed) are controlled by the timestep(just like DMC) a
nd the length of the path.  The larger the timestep and shorter the reptile, the more efficient and inaccurate the simulation. The length of the reptile should be 
around 1-3 a.u., depending on the quality of the trial wave function.

RMC accumulates two estimators: label and label\_cen.  label contains the 
mixed estimators, which are useful for the total energy and correlated
sampling energy differences.  
label\_cen contains the 'pure' estimator, which is useful for the local 
potential energy and polarization, as well as other properties that 
are specified with a DENSITY section(these automatically use the 
center estimator).

Required keywords:\\
\begin{tabular}{lp{12cm}}
{\bf NSTEP } & Integer.   Number of average points to take in a block. \\
{\bf NBLOCK} & Integer. Number of blocks to take \\
{\bf TIMESTEP} & Float. A measure of how large each move 
should be.  Adjust such that the acceptance ratio is about .99. Acceptance ratio
is just a general guide, however, and it's useful to do several time steps if you
need highly accurate results. \\
{\bf LENGTH} & Integer.  Number of points in the reptile.  Energy will be converged 
to LENGTH points, and all other quantities(density, potential, etc) will be converged to LENGTH/2 points. \\
{\bf READCONFIG } & String. Read from a configuration file
previously written by STORECONFIG.  Since RMC only uses one walker/node for memory reasons, if it is a VMC
configuration file, it will only take the first config, and ignore the rest.  The upshot of this is that you
only need to generate one config/node in VMC. \\
\end{tabular}


Optional keywords: \\
\begin{tabular}{lp{12cm}}
{\bf STORECONFIG } & String. Write the reptile to the file specified at the end of each block.  In parallel, each processor will write its configurations to this file with \_n a
ppended, where n is the processor number. \\
{\bf LABEL} & String.  Label in the .log file.  Defaults to rmc.\\
\end{tabular}

%\newpage 

\subsection{Walker dynamics}

VMC, DMC, and RMC all use a pluggable object to choose the walker steps.  There are
two options implemented at the time of this writing: SPLIT and UNR. 

 SPLIT consists
of the moves outlined in the Foulkes {\it et al.} RMP with a slight wrinkle: it 
can retry failed moves while maintaining detailed balance.  This mostly increases 
the efficiency when performing large moves; i.e., VMC.  It is the best 
choice when using pseudopotentials.

UNR uses the algorithm of Umrigar, Nightingale, and Runge.  It is the preferred 
algorithm for full-core atoms.

So, in summary, when performing calculations with pseudopotentials, either do nothing 
or put DYNAMICS \{ SPLIT DEPTH 2 \} in the VMC section.  With full-core atoms, put 
DYNAMICS \{ UNR \}.

%\newpage

\section{Basis functions}

A basis function is a function of three dimensions.  This is a general 
class that is used in many places throughout the code; both in evaluation of the 
trial wave function and in other places.

\subsection{Radial cubic spline}

Keyword: AOSPLINE \\



%\newpage

\section{Wave functions}
\subsection{Slater}

Keyword: SLATER \\


A Slater determinant or several determinants.  Also can use the same
molecular orbitals to create several separate combinations of determinants.

Required Keywords: \\
\begin{tabular}{lp{12cm}}
{\bf DETWT } & Section.  list of the weights of the determinants \\ 
{\bf STATES} & Section. List of the occupations of the molecular orbitals, first
spin up, then spin down.  For example, a RHF determinant might be 
1 2 3 
1 2 3 
and a UHF might be 
1 2 3 
4 5 6 
If there are more than one determinant, simply continue listing up and 
down occupations.  Also, list several STATES functions, and they
will be added as separate guiding functions. \\
{\bf ORBITALS} & Section. input for a Molecular orbital matrix\\
\end{tabular}

Optional keywords: \\
\begin{tabular}{lp{12cm}}
{\bf NSPIN } & Section. Override the global parameter given in SYSTEM for this wave function. \\
{\bf OPTIMIZE\_DET} & Flag.  Optimize the determinantal coefficients.  For a single 
determinant, this does nothing. Defaults to off.\\
\end{tabular}

%\newpage

\subsection{Jastrow}
Keyword: JASTROW or JASTROW2

A wave function as follows:

\begin{equation} 
\Psi_{Jastrow}(\bR)=\sum_{I,i<j} u(r_{Ii},r_{Ij}, r_{ij})
\end{equation}
where $I$ is the ionic/nuclear index and i/j are the electronic indices.  The actual form of $u$
is determined by the `piece' requested; there are one-body only pieces that only depend on $r_{Ii}$ and 
$r_{Ij}$, two-body pieces that depend only on $r_{ij}$, and three-body pieces that depend on all 
distances.

This is a multi-layered object: structure is as follows:
\begin{verbatim}
GROUP { 
   <Basis for this group>
   <Coefficients for this basis>
}
GROUP { 
   <same as above>
}
\end{verbatim}
This structure allows a fairly fine-grained control over optimization of the basis and coefficients; 
one can turn optimization on and off for different logical sections.  The options are further broken
down as follows: \\

Group options: \\
\begin{tabular}{lp{12cm}}
{\bf OPTIMIZEBASIS } & Flag. Optimize the nonlinear parameters in the basis functions. By default is off. \\
{\bf EIBASIS } & Electron-ion basis.  Multiple instances of these will be appended \\
{\bf EEBASIS } & Electron-electron basis.  Multiple instances will also be appended \\
{\bf ONEBODY } & Section. One-body part of the Jastrow expansion \\
{\bf TWOBODY } & Section. Two-body part, with spin-independent coefficients \\
{\bf TWOBODY\_SPIN } & Section. Two-body part, with spin-dependent (like/unlike) coefficents \\
{\bf THREEBODY } & Section. Three-body part, with spin-independent coefficients \\
\end{tabular}

The ONEBODY part is as follows: 
\begin{equation}
 u(r_{Ii},r_{Ij},r_{ij})=\sum_k c_{k}^{(I)} a_k^{(I)}(r_{Ii})
\end{equation}
and the sum over $j$ is not performed.
ONEBODY options: \\
\begin{tabular}{lp{12cm}}
{\bf FREEZE} & Flag. Do not optimize the coefficients \\
{\bf COEFFICIENTS } & Section.  First element is the label of the atom type and then following are a number of coefficients equal to or less than the number of EIBASIS functions for that atom type \\
\end{tabular}

The TWOBODY part is:
\begin{equation}
 u(r_{Ii},r_{Ij},r_{ij})=\sum_k c_{k} b_k(r_{ij})
\end{equation}
and the sum over $I$ is not performed.
TWOBODY options: \\
\begin{tabular}{lp{12cm}}
{\bf FREEZE} & Flag. Do not optimize the coefficients \\
{\bf COEFFICIENTS } & Section.  A number of coefficients equal to or less than the number of EEBASIS functions  \\
\end{tabular}

TWOBODY\_SPIN options: \\
\begin{tabular}{lp{12cm}}
{\bf FREEZE} & Flag. Do not optimize the coefficients \\
{\bf LIKE\_COEFFICIENTS } & Section.  A number of coefficients equal to or less than the number of EEBASIS functions  \\
{\bf UNLIKE\_COEFFICIENTS } & Section.  A number of coefficients equal to or less than the number of EEBASIS functions  \\
\end{tabular}

The THREEBODY part is as follows: 
\begin{equation}
u(r_{Ii},r_{Ij},r_{ij})=\sum_{klm} c_{klm}^{(I)} (a_k(r_{Ii})a_l(r_{Ij})+a_l(r_{Ii})a_k(r_{Ij}))b_m(r_{ij})
\end{equation}
where the $a$'s are from the EIBASIS and the $b$'s are from the EEBASIS inputs.  
THREEBODY options: \\
\begin{tabular}{lp{12cm}}
{\bf FREEZE} & Flag. Do not optimize the coefficients \\
{\bf SM\_TERMS} & Section.  A list of the Schmidt-Moskowitz coefficients to include.  This is done by 
specifying the $k$,$l$, and $m$ terms.  By default, this is \newline
1 1 0 \newline
1 0 1 \newline
1 1 1 \newline
2 2 0 \newline
2 0 1 \newline
2 0 2 \newline
2 2 2 \newline
3 3 0 \newline
3 0 2 \newline
3 3 2 \newline
1 2 2 \newline
2 3 2 
\\
{\bf COEFFICIENTS } & Section. A number of coefficients for each atom as in the ONEBODY input.  The 
number of coefficients should be less than or equal to the number of SM\_TERMS \\
\end{tabular}

\subsection{Pfaffian}
Keyword: PFAFFIAN


A pfaffian (generalized determinant) or several pfaffians. 

\begin{equation}
\Psi=\sum_i w_i \Psi_i
\end{equation}

\begin{equation}
\Psi_i={\rm pf}\left[ \begin{array}{ccc}
{\boldsymbol \xi}^{\uparrow\uparrow}_i & 
{\boldsymbol \Phi}^{\uparrow\downarrow}_i & 
 {\boldsymbol\varphi}^{\uparrow}_i \\
-{\boldsymbol \Phi}^{\uparrow\downarrow T}_i & 
{\boldsymbol \xi}^{\downarrow\downarrow}_i &
{\boldsymbol \varphi}^{\downarrow}_i \\
-{\boldsymbol\varphi}^{\uparrow T}_i &
 -{\boldsymbol\varphi}^{\downarrow T}_i &
 0 \;\; 
\end{array}
\right]
\end{equation}

where submatrices $ \boldsymbol \xi $, $ \boldsymbol  \Phi $ and $ \boldsymbol \varphi $ are defined in the Pfaffian group documentation
and ordered according the ORBITAL\_ORDER section.

Example:
\begin{verbatim}
Pfaffian wave function for the ground state of carbon pseudo-atom :
PFAFFIAN
  NPAIRS {  3  1  0  }
  PFWT {  1  }
  ORBITAL_ORDER {
  1    1    1
  1    1
  1
  }
  PAIRING_ORBITAL {
    ORBITALS_IN_PAIRING {  1  2  3  4  5  }
    OPTIMIZE_PF {
      NOCCUPIED 3
      SINGLET_ALL
    }
    TRIPLET_UU_COEF {
    0 0 0 0
    1 0 0
    0 0
    0
    }
    TRIPLET_DD_COEF {
    0 0 0 0
    0 0 0
    0 0
    0
    }
    SINGLET_COEF {
    1 0 0 0 0
    0 0 0 0
    0 0 0
    0 0
    0
    }
  }
  ORBITALS {
    CUTOFF_MO 
    MAGNIFY 1 
    INCLUDE c.basis 
    NMO 5 
    ORBFILE c.orb 
    CENTERS { USEATOMS }
    }
  }
\end{verbatim}

Required Keywords: \\
\begin{tabular}{lp{12cm}}
{\bf NPAIRS} & Section. number of spin-up, spin-down and unpaired electrons (the sum of these 3 numbers defines
 a pfaffian matrix of size $ N $)  \\
{\bf PFWT } & Section. list of the weights of the pfaffians (also defines the number of Pfaffians) \\
{\bf PAIRING\_ORBITAL} & Section. Section for a Pfaffian group defined below\\
{\bf ORBITALS} & Section.  Input for a MO matrix. \\
\end{tabular}

Optional Keywords: \\
\begin{tabular}{lp{12cm}}
{\bf ORBITAL\_ORDER} &  Section.  i-th pairing orbital for i-th pfaffian matrix 
>Contains upper-diagonal of $ N \times N $ matrix of pairing occupation numbers \\
{\bf OPTIMIZE\_PFWT} & Keyword. Optimize the pfaffian weights. Defaults to off \\
\end{tabular}


The pairing orbitals are defined as follows:\\
Keywords: \\
\begin{tabular}{lp{12cm}}
{\bf TRIPLET\_UU\_COEF} & Section. $ N(N-1)/2 $ normalized coefficients for triplet spin-up spin-up pair of form: 
$ \chi(1,2)= {1 \over \sqrt(2)} \sum_{i>j} a_{i,j}( \varphi_i(1)\varphi_j(2)- \varphi_j(1)\varphi_i(2))$. Defaults to all zero \\
{\bf TRIPLET\_DD\_COEF } & Section. same as above for spin-down case.  Also defaults to zero. \\
{\bf SINGLET\_COEF } & Section.  
$ N(N+1)/2 $ normalized coefficients 
for singlet spin-up spin-down pair of form:
$ \phi(1,2)= \sum_{i} s_{i,i} \varphi_i(1)\varphi_j(2) + {1 \over \sqrt(2)} \sum_{i>j} s_{i,j}( \varphi_i(1)\varphi_j(2)+\varphi_j(1)\varphi_i(2))$. Defaults to 1 on the diagonal for all occupied orbitals, zero otherwise. \\
{\bf UNPAIRED\_COEF} & Section.  Number of spin down $\times$ the number normalized coefficients for unpaired electron orbital of form: 
$ \varphi'_{i}(1)= \sum_{j} c_{i,j}\varphi_j(1)$. Defaults to all zero  \\

\end{tabular}


%\newpage

\subsection{Slater-Jastrow/Multiply}

Keyword: SLATER-JASTROW or MULTIPLY

Multiply two wave functions

Options:\\
\begin{tabular}{lp{12cm}}
{\bf WF1} &  Section. A wave function section \\
{\bf WF2} & Section. A wave function section \\
\end{tabular}


\section{Molecular orbitals}
\subsection{Cutoff MO}
\subsection{BLAS} 
\subsection{Standard}

\section{Local density accumulators}

\section{Average accumulators}

\section{Qavg}


\end{document}