type: Entry
name: DMC
keyword: DMC
is_a: Method
title: Diffusion Monte Carlo
related: []
description: > 
  In this implementation of DMC, we use something similar to the Umrigar
  Nightingale, Runge paper, with some modifications.  Electrons are moved 
  one-by-one, and there is an effective timestep for the branching part of 
  the green's function.  


  We use a modification of the branching algorithm 
  that ensures a constant number of walkers.
  Every few DMC steps, search for high weights.  If one with greater than 
  some threshold(1.8) do the following.
  Search for the walker with the lowest weight(w2) that hasn't already 
  branched
  Branch the first walker and kill the second walker with probability 
  \( p=\frac{w_1}{w_1+w_2}\).  Otherwise branch the second walker and 
  kill the first walker.


  This ensures a constant number of walkers, which improves the 
  parallel efficiency--it is easy to scale up to hundreds of thousands of processors
  with 99% efficiency.
required:
  - keyword: TIMESTEP
    type: float
    description: > 
      A measure of how large each move 
      should be.  Adjust such that the acceptance ratio is about .99. Acceptance ratio
      is just a general guide, however, and it's useful to do several time steps if you
      need highly accurate results.
optional: 
  - keyword: AVERAGE
    type: section
    default: empty
    description: Section for an [Average generator](Average generator)
  - keyword: SAVE_TRACE
    type: string
    default: none
    description: Every block, save the current configurations and their weights (in binary). Note that since this is a binary file, you may need to use the utility swap\_endian (provided in utils) to change architectures.
  - keyword: TMOVES
    type: flag
    default: off
    description: > 
      Use Michele Casula's T-moves, which
      makes DMC rigorously variational when there are non-local pseudopotentials
      at the cost of increasing the timestep error slightly
     
