/*! \page Reptation_methodDoc Reptation Monte Carlo method

Keyword: REPTATION

\section description Description

This is an implementation of the Reptation Monte Carlo method(PRL 82, 4745 (1999)).  There are quite a few modifications to the algorithm as presented in the above paper.  Some are outlined in a paper by Pierleoni and Ceperley that's floating around on the net, most importantly the bounce algorithm.  RMC is conceptually similar to DMC, in that we sample the distribution \f$\Psi_T e^{-H\tau} \Psi_T \f$, with the projection operator interpreted as a random walk.  At each end of the walk, we have sampled \f$\Psi_T \Phi_0\f$, the mixed distribution.  In the center, we have \f$\Phi_0^2\f$, since on either side there are projection operators.  DMC only moves forward, so the center distribution is unavailable, except by forward walking, which simulates the effect of projection operators.  In RMC, the random variable is the path, which, for finite length, can be a probability density.  Therefore, there's no branching and no population control bias.  The biases (and speed) are controlled by the timestep(just like DMC) and the length of the path.  The larger the timestep and shorter the reptile, the more efficient and inaccurate the simulation.  For chemical systems, I've found a good starting point is a reptile about 3 au long, and a timestep around .01 au, which corresponds to TIMESTEP .01  and LENGTH 300.  Note that you have to scale the length with the timestep to maintain total projection length.

RMC accumulates two estimators: label and label_cen.  label contains the 
mixed estimators, which are useful for the total energy and correlated
sampling energy differences.  
label_cen contains the 'pure' estimator, which are useful for the local 
potential energy and polarization, as well as other properties that 
are specified with a DENSITY section(these automatically use the 
center estimator).  For finite differences, auxdiffn-0 is the Filippi & 
Umrigar estimator, while auxdiffn-1 is the 'Full' estimator from 
Pierleoni and Ceperley.  For simple materials with good wave functions, they
should give very similar values, with the F-U estimator more efficient and perhaps
more likely to be accurate.

\section options Options

\subsection reqopt Required 

<table>
<tr> <td> <b>Option</b> <td> <b>Type</b> <td> <b>Description</b>

<tr> <td> NSTEP <td> Integer <td>  Number of average points to take in a block.
<tr> <td> NBLOCK <td> Integer <td>  Number of blocks to take
<tr> <td> TIMESTEP <td> Float <td>  A measure of how large each move 
should be.  Adjust such that the acceptance ratio is about .99. Acceptance ratio
is just a general guide, however, and it's useful to do several time steps if you
need highly accurate results.
<tr> <td> LENGTH <td> Integer <td>  Number of points in the reptile.  Energy will be converged to LENGTH points, 
and all other quantities(density, potential, etc) will be converged to LENGTH/2 points.
<tr> <td> READCONFIG <td> String <td> Read from a configuration file
previously written by STORECONFIG.  Since RMC only uses one walker/node for memory reasons, if it is a VMC
configuration file, it will only take the first config, and ignore the rest.  The upshot of this is that you
only need to generate one config/node in VMC.
</table>

\subsection optopt Optional

<table>
<tr> <td> <b>Option</b> <td> <b>Type</b> <td> <b> Default </b> 
     <td> <b>Description</b>
<tr> <td> STORECONFIG <td> String <td> none <td> Write the reptile to the file specified.  In parallel, each processor will write its configurations to this file with _n appended, where n is the processor number.
<tr> <td> LABEL <td> String <td> rmc <td> Label in the .log file.
<tr> <td> DYNAMICS <td> Section <td> SPLIT 
     <td> choose a dynamics generator.  possible options are { SPLIT }, {RUNGE  }.  The split dynamics generator is generally more efficient, so don't touch
it unless you know what you're doing.
<tr> <td> DENSITY <td> Section <td> empty 
     <td> A section for a  \ref Local_density_accumulatorDoc .  This will be 
measured at the center of the reptile, to obtain a 'pure' estimator.
</table>


\subsection expopt Experimental

<table>
<tr> <td> <b>Option</b> <td> <b>Type</b> <td> <b> Default </b> 
     <td> <b>Description</b>
<tr> <td> FULL_GF <td> Flag <td> Off <td> Try to use the Full Green's function
to go beyond Filippi and Umrigar's method for correlated sampling.  Note that 
this may not be better and is still very much in an experimental phase.

</table>


*/
